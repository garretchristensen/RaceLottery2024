---
title: "High Lonesome 2024 Lottery"
author: "Garret Christensen"
output: html_document
date: "2023-12-12"
runtime: shiny
---
Welcome to the High Lonesome 2024 Lottery. This lottery is run with code written by ultra-marathoner/economist/nerd [Garret Christensen](http://garrettheonion.blogspot.com). The code is available on GitHub [here](http://www.github.com/garretchristensen/RaceLottery2024). The intent with using Github is to make the entire process transparent and reproducible. If you speak R, or want to help me improve the graphical interface, please check it out!		


```{r prep, echo=FALSE, results=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(tibble)
library(readxl)
library(markdown)
library(shiny)
library(shinyBS)

temp<-read.csv("./2024 HiLo lottery data_FINALnoemail.csv", stringsAsFactors = FALSE) #LOAD THE DATA
df<-as_tibble(temp)
#THERE IS SOME STUPID NON-ASCII CHARACTER BEGINNING-OF-FILE 
#NONSENSE GOING ON HERE
#CHEAP WORKAROUND IS JUST TO MAKE SURE FIRST_NAME IS NOT THE FIRST VARIABLE!
#names(df) <- iconv(names(df), to='ASCII', sub='')
#df$First_Name<-df$..First_Name

df$fullname<-paste(df$First_Name, df$Last_Name, sep=" ", collapse = NULL)
head(df)

#df$USA<-ifelse(df$Country=="USA",1,0)

#NUMBER OF MEN AND WOMEN APPLICANTS
n_men_app=nrow(men<-df[which(df$Gender=="M"),])
n_women_app=nrow(women<-df[which(df$Gender=="F"),])
```

```{r main, echo=FALSE, results=TRUE, warning=FALSE, message=FALSE}
shinyApp(
  ui<-fluidPage(
    
    
    
bsCollapse(id = "collapse", multiple=TRUE,
  bsCollapsePanel("Lottery Background",
                   htmltools::includeMarkdown("./markdown/background.md"), style = "info"),
  bsCollapsePanel("What are my odds?",
                  htmltools::includeMarkdown("./markdown/justtellmetheodds.md"),
                  column(6, sliderInput("apps", label = h5("Previous applications"), min=0, max=5, value = 0)),
                  column(6, sliderInput("finishes", label = h5("Previous Finishes"), min=0, max=5, value = 0)),
                  column(6, sliderInput("volunteer", label = h5("Volunteer Shifts"), min=0, max=30, value = 0)),
                  column(6, sliderInput("trailwork", label = h5("Extra Trailwork"), min=0, max=10, value = 0)),
                 "Your tickets in the lottery:", textOutput("tickets"),
                  style = "success"
  ),
  
  bsCollapsePanel("Set the Seed", 
    htmltools::includeMarkdown("./markdown/implementingthelottery.md"),  
    column(6, numericInput("num", label = h1("Enter the seed"), value = NA)),
    column(6, numericInput("num2", label = h1("Confirm the seed"), value = NA)),
    style="info" 
  )
),    
  
 
  fluidRow(verbatimTextOutput("value")),
  fluidRow("These are the women selected in the lottery:", tableOutput("women")),
  fluidRow("These are the men selected in the lottery:", tableOutput("men")),
  
  htmltools::includeMarkdown("./markdown/herearethewaitlists.md"),
  fluidRow("These are the waitlists. Women first, then men:", tableOutput("combo")),
  fluidRow(downloadButton("report", "Download Results")) 


  ), 
  server<- function(input, output) {
    
    output$tickets <- renderText({
#Do THE VARIABLE TRANSFORMATIONS FOR PEOPLE's ENTERED VALUES
k_sim <- ifelse(input$finishes==0 , 0,
               ifelse(input$finishes==1,  0.5,
                      ifelse(input$finishes==2, 1, 
                             ifelse(input$finishes==3, 1.5,
                                    ifelse(input$finishes>=4, 0.5, 0)))))


#Shifts max out at 30 (10 each race)
v_sim<-pmin(input$volunteer, 30)
t_sim<-pmin(input$trailwork, 10)

#Tickets=2^(n+k+1)+2ln(v+t+1) where n, k, v, and t are defined as follows:
2^(k_sim+input$apps+1) + 2*log(v_sim+t_sim+1)

}) #END RENDER TEXT
    
    
    
    
    
    winners <- reactive({
      req(input$num, input$num2)
      
      if (input$num == input$num2) {
        #sample_n(women, 3, replace = FALSE)
        
        
        
        
        
        set.seed(input$num) #SET THE SEED WITH DICE!
        nm<-input$Nm #SET THE TOTAL NUMBER TO PICK
        nw<-input$Nw #SET THE TOTAL NUMBER TO PICK

######################################################################
#FOR 2024 JUST SET HOW MANY TO PICK
        n_women_pick <- 68
        n_men_pick <- 63
      
######################################################################
#DETERMINE TICKETS FROM THE DATA
#For 2020 nobody has unsuccessful applications, this is the first lottery
        df$Applications<-df$Previous_Applications

#k is defined according to the following rule:
# k=0 if finishes==0
#k=0.5 if finishes==1
#k=1 if finishes==2
#k=1.5 if finishes==3
#k=1 if finishes>=4
        df$k <- ifelse(df$Previous_Finishes==0 , 0,
               ifelse(df$Previous_Finishes==1,  0.5,
                      ifelse(df$Previous_Finishes==2, 1, 
                             ifelse(df$Previous_Finishes==3, 1.5,
                                    ifelse(df$Previous_Finishes>=4, 0.5, 0)))))


#Shifts max out at 30 (10 each race)
      df$v<-pmin(df$Volunteer_Shifts, 30)
      df$t<-pmin(df$Extra_Trailwork, 10)

#Tickets=2^(n+k+1)+2ln(v+t+1) where n, k, v, and t are defined as follows:
    df$tickets <-2^(df$k+df$Applications+1) + 2*log(df$v+df$t+1)

##########################################################



   #SPLIT THE DATA INTO MENS AND WOMENS
   men<-df[which(df$Gender=="M"),]
   women<-df[which(df$Gender=="F"),]


##############################################################
#DRAW THE LOTTERY

    #dplyr function sample_n will work with weights, normalize automatically
    #syntax:sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...)
    #Run the separate lotteries
    women_winners<-sample_n(women, n_women_pick, replace = FALSE, weight=women$tickets)
    men_winners<-sample_n(men, n_men_pick, replace = FALSE, weight=men$tickets)
    
    #I can't figure out how to label tables, so just make the table itself
    #look sort of well-labeled
    #subset
    #dfnew5 <- subset(diamonds, select=c("color", "carat", "price"))
    w_output<-subset(women_winners, select=c("fullname", "City", "State"))
    m_output<-subset(men_winners, select=c("fullname", "City", "State"))
    
    #Add ID column data$ID <- seq.int(nrow(data))
    w_output$Num<-seq.int(nrow(w_output))
    m_output$Num<-seq.int(nrow(m_output))
    #rearrange columns df2[,c(1,3,2,4)]
    #w_output<-w_output[,c(5,1,2,3,4)]
    #m_output<-m_output[,c(5,1,2,3,4)]
    #rename: names(data)[3]<-"new_name"
    names(w_output)[1]<-"Selected_Women"
    names(m_output)[1]<-"Selected_Men"
    
  #########################################################
  #waitlist
  #########################################################

    women_waitlist_pool<-anti_join(women, women_winners)
    n_women_waitlist_pool<-nrow(women_waitlist_pool)
 
  men_waitlist_pool<-anti_join(men, men_winners)
  n_men_waitlist_pool<-nrow(men_waitlist_pool)
    
  #SIMPLER THIS YEAR, JUST ENTER THE NUMBERS FOR THE WL, 8 and 7
  n_women_wait_pick<-75
  n_men_wait_pick<-75
  
  #PICK THE WAITLISTERS
  #WOMEN MIGHT NOT HAVE ANY

    women_waiters <- sample_n(women_waitlist_pool, n_women_wait_pick, replace = FALSE, weight=women_waitlist_pool$tickets)
    w_output_wait<-subset(women_waiters, select=c("fullname", "City", "State"))
    #w_output_wait_priv<-subset(women_waiters, select=c("fullname", "Email_Address"))
    w_output_wait$Num<-seq.int(nrow(w_output_wait))
    #w_output_wait<-w_output_wait[,c(5,1,2,3,4)]
    names(w_output_wait)[1]<-"Waitlisted_Women"
    output$women_wait <- renderTable(w_output_wait)
  
  #ASSUME MEN WILL HAVE ENOUGH FOR A FULL WAITLIST
  men_waiters <- sample_n(men_waitlist_pool, n_men_wait_pick, replace = FALSE, weight=men_waitlist_pool$tickets)
      
  m_output_wait<-subset(men_waiters, select=c("fullname", "City", "State"))

  m_output_wait$Num<-seq.int(nrow(m_output_wait))
 
  names(m_output_wait)[1]<-"Waitlisted_Men"
  #Send the winners' names to be output
  output$men_wait <- renderTable(m_output_wait)   
  
      
  ##########################################
  #Don't Zipper the waitlists
  ########################################
  #make column names identical so columns line up
  names(m_output_wait)[1]<-"Waitlisted_Name"
  names(w_output_wait)[1]<-"Waitlisted_Name"
  #bind women first for the waitlist for 2021
  
  temp <- bind_rows(w_output_wait, m_output_wait)
  output$women <- renderTable(w_output)
  output$men <- renderTable(m_output)
  output$combo<-renderTable(temp)      
  } # CLOSE IF
  }) #CLOSE REACTIVE
  
    #HAVE THE RENDER PRINT RUN BY ITSELF  
    output$value <- renderPrint({
      winners()
    }) #END RENDER PRINT
  }, #CLOSE SERVER
 options = list(height = 900) 
)


#TRY THE DOWNLOAD
output$report <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "results.html",
      content = function(file) {
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "results.Rmd")
        file.copy("results.Rmd", tempReport, overwrite = TRUE)

        # Set up parameters to pass to Rmd document
        params <- list(n = input$num)

        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the document
        # from the code in this app).
        rmarkdown::render(tempReport, output_file = file,
          params = params,
          envir = new.env(parent = globalenv())
        )
      }
    )





```
